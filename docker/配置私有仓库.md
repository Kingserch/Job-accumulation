+ ### 配置私有仓库 
    + [仓库](#仓库)
    + [配置registry](#配置文件管理私有仓库)
    + [批量管理镜像](#批量管理镜像)
    + [使用通知系统](#使用通知系统)
+ ### 仓库
##### 1.安装Dcoker Registry,基于容器安装  
`docker run -d -p 5000:5000 --restart=always --name registry registry:2`  
##### 2.本地安装运行
```
yum install -y epel-release	
yum install golang -y
go version
go version go1.13.3 linux/amd64
mkdir -p $GOPATH/src/github.com/docker/	
cd $GOPATH/src/github.com/docker/
git clone https://github.com/docker/distribution.git	
```
##### 3.配置TLS证书
```
[root@m129 ~]# docker tag centos:7 registry:5000/centos:7	#本地的centos镜像上传到仓库
[root@m129 ~]# docker push registry:5000/centos:7	#推到仓库
[root@m129 ~]# mkdir -p /root/certs	#创建存放TLS证书的目录
[root@m129 ~]# openssl req -newkey rsa:4096 -nodes -sha256 -keyout /root/certs/repo.key -x509 -days 365 -out /root/certs/repo.crt
Generating a 4096 bit RSA private key
...................................++
.....................................................................................................................++
writing new private key to 'certs/repo.key'
-----
You are about to be asked to enter information that will be incorporated
into your certificate request.
What you are about to enter is what is called a Distinguished Name or a DN.
There are quite a few fields but you can leave some blank
For some fields there will be a default value,
If you enter '.', the field will be left blank.
-----
Country Name (2 letter code) [XX]:ki	#国家名称
State or Province Name (full name) []:henan	#省
Locality Name (eg, city) [Default City]:zz	#地区城市
Organization Name (eg, company) [Default Company Ltd]:sj	#公司
Organizational Unit Name (eg, section) []:yw	#职位
Common Name (eg, your name or your server's hostname) []:192.168.10.129	#服务器名称或者ip
Email Address []:2249155086@qq.com	#邮箱
[root@m129 ~]# cd certs/
[root@m129 certs]# ls
repo.crt  repo.key	#秘钥文件repo.key，证书文件repo.crt，这个文件是需要发给用户，配置到用户docker hosts上，
[root@m129 certs]# docker run -d --restart=always --name registry -v 'pwd'/certs:/certs -e REGISTRY_HTTP_ADDR=0.0.0.0:443 -e REGISTRY_HTTP_TLS_CERTIFICATE=/root/certs/repo.crt -e REGISTRY_HTTP_TLS_KEY=/root/certs/repo.key -p 443:443
#上命令是启动证书
```
##### 4.管理访问权限
具体交互过程包括如下步骤：
* Docker Daemon或者其他客户端尝试访问Registry服务器，比如pull、push或者访问manifiest文件；
* 在Registry服务器开启了认证服务模式时，就会直接返回401 Unauthorized错误，并通知调用方如何获得授权；
* 调用方按照要求，向Authorization Service发送请求，并携带Authorization Service需要的信息，比如用户名、密码；
* 如果授权成功，则可以拿到合法的Bearer token，来标识该请求方可以获得的权限；
* 请求方将拿到Bearer token加到请求的Authorization header中，再次尝试步骤1中的请求；
* Registry服务通过验证Bearer token以及JWT格式的授权数据，来决定用户是否有权限进行请求的操作。
配置nginx代理
```
sudo rpm -Uvh http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpm	
sudo yum install -y nginx
sudo systemctl start nginx
sudo systemctl enable nginx
##Add		#开放80端口
firewall-cmd --permanent --zone=public --add-port=80/tcp
##Reload
firewall-cmd --reload
[root@m129 default.d]# vim /etc/nginx/default.d/default.conf 在default.conf文件中添加代理配置
# 本地的registry服务监听在5000端口
upstream docker-registry {
server localhost:5000;
}

# 本地的registry服务监听在5000端口
upstream docker-registry {
	server localhost:5000;
   }

#代理服务器监听在5000端口
server {
    listen 5000;
    server_name private-registry-server.com;
    add_header 'Docker-Distribution-Api-Version' 'registry/2.0' always;
# If you have SSL certification files, then can enable this section.
    ssl on;
    ssl_certificate /etc/nginx/ssl/repo.crt;
    ssl_certificate_key /etc/nginx/ssl/repo.key;
    proxy_pass                        http://docker-registry;
    proxy_set_header   Host           \$http_host;     #  required  for  docker
    client's sake
    proxy_set_header  X-Real-IP           \$remote_addr; # pass on real client's IP
    proxy_set_header   X-Forwarded-For    \$proxy_add_x_forwarded_for;
    proxy_set_header   X-Forwarded-Proto \$scheme;
    proxy_read_timeout                       600;

    client_max_body_size  0;  #  disable  any  limits  to  avoid  HTTP  413  for  large
            image uploads
# required to avoid HTTP 411: see Issue #1486(https://github.com/dotcloud/docker/issues/1486)
    chunked_transfer_encoding on;

    location /v2/ {
        # 禁止旧版本 Docker 访问
        if (\$http_user_agent ~ "^(docker\/1\.(3|4|5(? ! \.[0-9]-dev))|Go ).＊\$" ) {
            return 404;
             }
		# 配置转发访问请求到registry服务
		proxy_pass http://docker-registry;
	    }
	}
[root@m129 /]# docker tag centos:7 127.0.0.1:5000/centos:7
root@m129 /]# docker push 127.0.0.1:5000/centos:7
The push refers to repository [127.0.0.1:5000/centos]	#可以看到已经存在了
77b174a6a187: Layer already exists 
7: digest: sha256:285bc3161133ec01d8ca8680cd746eecbfdbc1faa6313bd863151c4b26d7e5a5 size: 529
[root@m129 /]#
```
##### 5.添加用户认证  
公共仓库DockerHub是通过注册索引服务来实现的，但并不完善，所以用nginx代理的用户访问管理方案，Nginx支持基于用户名和密码的访问管理
```
[root@m129 default.d]# vim default.conf 
	....
        location / {
            # 这里改动了 定义首页索引文件的名称
            index index.php index.jsp index.html index.htm;
            # let Nginx know about our auth file	#新加的内容
            auth_basic                  "Please Input username/password";	#启动认证服务，不通过请求无法转发
            auth_basic_user_file     docker-registry-htpasswd;	#指定验证用户名密码的存储文件为本地/etc/nginx/下的docker-registry-htpasswdwd文件
			proxy_pass http://docker-registry;
        }
	...
[root@m129 default.d]# systemctl restart nginx
[root@m129 nginx]# touch docker-registry-htpasswdwd
[root@m129 nginx]# vim docker-registry-htpasswdwd 	#密码字段存储不是明文的，是使用crypt函数加密过的字符串，用htpasswd工具。
#用户名:密码
kingserch:qax123123
 ```
+ ### 配置文件管理私有仓库
##### 1.示例配置
```
version: 0.1

    log:		
        level: debug
        fields:
            service: registry
            environment: development
        hooks:		
            - type: mail
              disabled: true
              levels:
                - panic
              options:
                smtp:

     addr: mail.example.com:25
                    username: mailuser
                    password: password
                    insecure: true
                from: sender@example.com
                to:
                    - errors@example.com
    storage:
        delete:
            enabled: true
        cache:
                blobdescriptor: redis
        filesystem:
                rootdirectory: /var/lib/registry
        maintenance:
                uploadpurging:
                    enabled: false
    http:
        addr: :5000
        debug:
            addr: localhost:5001
        headers:
            X-Content-Type-Options: [nosniff]
    redis:
        addr: localhost:6379
        pool:
            maxidle: 16
            maxactive: 64
        idletimeout: 300s
        dialtimeout: 10ms
        readtimeout: 10ms
        writetimeout: 10ms
    notifications:
        endpoints:
            - name: local-5003
              url: http://localhost:5003/callback
              headers:
                Authorization: [Bearer <an example token>]
              timeout: 1s
              threshold: 10
              backoff: 1s
              disabled: true
            - name: local-8083
              url: http://localhost:8083/callback

              timeout: 1s
              threshold: 10
              backoff: 1s
              disabled: true
    health:
        storagedriver:
            enabled: true
            interval: 10s
            threshold: 3
```
##### 2.文件选项
`文件格式为yaml，比较重要的选项包括版本信息，log,hooks,存储选项，认证选项，HTTP选项，通知选项，redis选项，健康监控选项，代理，验证`
* log选项
```
    log:		
        level: debug	#字符串类型，标注输出调试信息的级别，包括debug、info、warn、error   
	formatter:text	#字符串类型，日志输出的格式，包括text、json、logstash等
        fields:		#增加到日志输出消息中的键值对，可以用于过滤日志  
            service: registry  
            environment: staging  
```
* hosts选项  
`配置当仓库发生异常时，通过邮件发送日志时的参数`

        hooks:
            - type: mail
              levels:
                    - panic
            options:
                smtp:
                        addr: smtp.sendhost.com:25	#邮箱的地址
				  username: sendername	
                        password: password
                        insecure: true
                    from: name@sendhost.com
                    to:

                        - name@receivehost.com
* 存储选项
```
age:
filesystem:
            rootdirectory: /var/lib/registry
        azure:
            accountname: accountname
            accountkey: base64encodedaccountkey
            container: containername
        gcs:
            bucket: bucketname
            keyfile: /path/to/keyfile
            rootdirectory: /gcs/object/name/prefix
        s3:
            accesskey: awsaccesskey
			   secretkey: awssecretkey
            region: us-west-1
            regionendpoint: http://myobjects.local
            bucket: bucketname
            encrypt: true
            keyid: mykeyid
            secure: true
            v4auth: true
            chunksize: 5242880
            multipartcopychunksize: 33554432
            multipartcopymaxconcurrency: 100
            multipartcopythresholdsize: 33554432
            rootdirectory: /s3/object/name/prefix
        swift:
            username: username
            password: password
            authurl: https://storage.myprovider.com/auth/v1.0 or
                https://storage.myprovider.com/v2.0  or  https://storage.myprovider.
                    com/v3/auth
            tenant: tenantname
            tenantid: tenantid
            domain: domain name for Openstack Identity v3 API
            domainid: domain id for Openstack Identity v3 API
            insecureskipverify: true
			    region: fr
            container: containername
            rootdirectory: /swift/object/name/prefix
        oss:
            accesskeyid: accesskeyid
            accesskeysecret: accesskeysecret
            region: OSS region name
            endpoint: optional endpoints
            internal: optional internal endpoint
            bucket: OSS bucket
            encrypt: optional data encryption setting
            secure: optional ssl setting

            chunksize: optional size valye
            rootdirectory: optional root directory
        inmemory:
        delete:		#是否允许删除镜像功能，默认关闭
            enabled: false
        cache:	#开启对镜像层元数据的缓存功能，默认开启
            blobdescriptor: inmemory
        maintenance:	#配置维护相关的功能，包括对孤立旧文件的清理，开启只读模式
            uploadpurging:
                enabled: true
                age: 168h
                interval: 24h
                dryrun: false
        redirect:
            disable: false
```
* 认证选项
```
auth:
        silly:		#测试用，请求头带有认证域即可，不做内容检查
            realm: silly-realm
            service: silly-service
        token:		#基于token的用户认证，适用生产环境，需要额外的token服务来支持
            realm: token-realm
            service: token-service
            issuer: registry-token-issuer
            rootcertbundle: /root/certs/bundle
        htpasswd:	#基于apache htpasswd密码文件的权限检查
            realm: basic-realm
```
* http选项
```
 http:
        addr: localhost:5000	#addr必须填写，服务监听地址
        net: tcp
        prefix: /my/nested/registry/
        host: https://myregistryaddress.org:5000
        secret: asecretforlocaldevelopment	#必选，与安全相关的随机字符串，用户可以自定义
        relativeurls: false

        tls:	#证书相关的文件路径
            certificate: /path/to/x509/public
            key: /path/to/x509/private
       clientcas:
                - /path/to/ca.pem
                - /path/to/another/ca.pem
            letsencrypt:
                cachefile: /path/to/cache-file
                email: emailused@letsencrypt.com
        debug:
            addr: localhost:5001
        headers:
            X-Content-Type-Options: [nosniff]
        http2:	#是否开启http2支持，默认关闭
            disabled: false
```
* 通知选项
```
endpoints:
            - name: alistener
              disabled: false
              url: https://my.listener.com/event
              headers: <http.Header>
              timeout: 500
              threshold: 5
              backoff: 1000
```
* redis选项
```
# Registry可以用Redis来缓存文件块，这里可以配置相关选项：
redis:
    addr: localhost:6379
    password: asecret
    db: 0
    dialtimeout: 10ms
    readtimeout: 10ms
    writetimeout: 10ms
    pool:
         maxidle: 16
         maxactive: 64
         idletimeout: 300s
```
* 健康监控选项
```
# 与健康监控相关，主要是对配置服务进行检测判断系统状态,这个默认未启用的
health:
        storagedriver:
            enabled: true
            interval: 10s
            threshold: 3
        file:
            - file: /path/to/checked/file
              interval: 10s
        http:
            - uri: http://server.to.check/must/return/200
              headers:
                Authorization: [Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==]
            statuscode: 200
            timeout: 3s
            interval: 10s
            threshold: 3
        tcp:
            - addr: redis-server.domain.com:6379
              timeout: 3s
              interval: 10s
              threshold: 3
```
* 代理选项
```
# 配置Registry作为一个pull代理，从远端（目前仅支持官方仓库）下拉Docker镜像
    proxy:
        remoteurl: https://registry-1.docker.io
        username: [username]
        password: [password]
之后，用户可以通过如下命令来配置Docker使用代理
    $ docker --registry-mirror=https://myrepo.com:5000 daemon
```
* 验证选项
```
# 限定来自指定地址的客户端才可以执行push操作
    validation:
        enabled: true
        manifests:
            urls:
                allow:
				   - ^https? ://([^/]+\.)＊example\.com/
                deny:
                    - ^https? ://www\.example\.com/
```
+ ### 批量管理镜像
##### 1.批量上次指定镜像

`vim push_images.sh 		#脚本内容`

[脚本内容](https://github.com/Kingserch/Job-accumulation/blob/Docker/sh/push_images.sh)
```
chmod +x push_images.sh
[root@m129 scripts]# sh push_images.sh centos:7
The registry server is 127.0.0.1:5000
Uploading centos:7...
The push refers to repository [127.0.0.1:5000/centos]
77b174a6a187: Layer already exists 
7: digest: sha256:285bc3161133ec01d8ca8680cd746eecbfdbc1faa6313bd863151c4b26d7e5a5 size: 529
Untagged: 127.0.0.1:5000/centos:7
Untagged: 127.0.0.1:5000/centos@sha256:285bc3161133ec01d8ca8680cd746eecbfdbc1faa6313bd863151c4b26d7e5a5
Done
```
`上传后，查看本地镜像，会发现上传中创建的临时标签也没清理了。棒棒哒`
##### 2.上传本地所有镜像
```
[root@m129 scripts]# cat push_all.sh 
#!/bin/bash
#Author:king
#Usage: push_all
for image  in  'docker  images|grep  -v  "REPOSITORY"|grep  -v  "<none>"|awk  '{print
        $1":"$2}''
    do
        push_images.sh $image
done
```
+ ### 使用通知系统
Docker Registry v2内置提供了Notification。提供了非常方便，快捷地集成接口，Notification功能其实就是Registry在有事件发生的时候，向用户自己定义的地址发送webhook通知，目前事件包括镜像manifext的push pull，镜像层的push，pull，这些动作将被序列化承webhook事件的payload，为集成服务提供事件详情，并通过Registry v2的内置广播系统发送到用户定义的服务接口，统称为Endpoints。  
Registry服务器的事件会通过HTTP协议发送到用户定义的所有Endpoints上，而且每个Registry实例的每个Endpoint都有自己独立的队列、重试选项以及HTTP的目的地址。当一个动作发生时，会被转换成对应的事件并放置到一个内存队列中。镜像服务器会依次处理队列中的事件，并向用户定义的Endpoint发送请求。事件发送处理是串行的，但是Registry服务器并不会保证其到达顺序。
##### 1.相关配置
```
    notifications:
        endpoints:
            -   name: cd-handler
                disabled: false
                url: http://cd-service-host/api/v1/cd-service
                headers:
                    Authorization: [token ＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊]
                timeout: 1s
                threshold: 5
                backoff: 10s
```
`上面的配置会在pull或者push发生时向http://cd-service-host/api/v1/cd-service发送事件，并在HTTP请求的header中传入认证信息，可以是Basic、token、Bearer等模式，主要用于接收事件方进行身份认证。更新配置后，需要重启Registry服务器，如果配置正确，会在日志中看到对应的提示信息,比如`
```
    configuring  endpoint  listener  (http://cd-service-host/api/v1/cd-service),  time-
        out=1s, headers=map[Authorization: [token ＊＊＊＊＊＊]]
```
`此时，用户再通过docker客户端进行push、pull，或者查询一些manifiest信息时，就会有相应的事件发送到定义的Endpoint上。`
`接下来看一下事件的格式及其主要属性：`
```
    {
        "events": [
            {
			         "id": "70f44894-c4b4-4be8-9691-d37db77074cd",
                "timestamp": "2016-06-05T01:57:04.654256149Z",
                "action": "push",
                "target": {
                    "mediaType":  "application/vnd.docker.distribution.manifest.v1+
                        json",
                    "size": 45765,
                    "digest":  "sha256:fd0af29ba2ae034449bffb18dd6db2ed90d798464cc43a
                        a81e63770713edaea8",
                    "length": 45765,
                    "repository":“test-user/hello-world”,
                    "url": "http://registry-server/v2/test-user/hello-world/manifests/
                        sha256:fd0af29ba2ae034449bffb18dd6db2ed90d798464cc43aa81e6377
                        0713edaea8"
                },
                "request": {
                    "id": "9d3d837f-d7ed-4fa9-afb4-dda58687a6ce",
                    "addr":“client-host:46504",
                    "host":“registry-server",
                    "method": "PUT",
					          "useragent": "docker/1.9.1 go/go1.4.2 git-commit/a34a1d5 kernel/
                        4.2.0-35-generic os/linux arch/amd64"
                },
                "actor": {
                    "name":“test-user"
                },
                "source": {
                    "addr": "8e14c2a190f2:5000",
                    "instanceID": "c564003e-dd9b-4a9b-8a30-fe8564e97ba9"
                }
            }
        ]
    }
```
	

